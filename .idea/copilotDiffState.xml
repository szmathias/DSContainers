<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/include/CStandardCompatibility.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/CStandardCompatibility.h" />
              <option name="originalContent" value="//&#10;// Created by zack on 8/27/25.&#10;//&#10;&#10;#ifndef DS_CSTANDARDCOMPATIBILITY_H&#10;#define DS_CSTANDARDCOMPATIBILITY_H&#10;&#10;#include &quot;PlatformDefs.h&quot;&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/* Require C11 or higher */&#10;#if !defined(__STDC_VERSION__) || __STDC_VERSION__ &lt; 201112L&#10;    #error &quot;C11 or higher required&quot;&#10;#endif&#10;&#10;/* Detect C23 for standard attributes */&#10;#if __STDC_VERSION__ &gt;= 202311L&#10;    #define COMPAT_HAS_C23 1&#10;#endif&#10;&#10;#if !defined(COMPAT_HAS_C23) || !defined(__cplusplus)&#10;    #define nullptr ((void*)0)&#10;    #define constexpr const&#10;    #include &lt;stdbool.h&gt;&#10;    #define static_assert(condition, message) _Static_assert(condition, message)&#10;#endif&#10;    &#10;/* Attribute compatibility macros */&#10;#ifdef COMPAT_HAS_C23&#10;    #define DS_NODISCARD [[nodiscard]]&#10;    #define DS_DEPRECATED [[deprecated]]&#10;    #define DS_NORETURN [[noreturn]]&#10;#elif defined(__GNUC__) || defined(__clang__)&#10;    #define DS_NODISCARD __attribute__((warn_unused_result))&#10;    #define DS_DEPRECATED __attribute__((deprecated))&#10;    #define DS_NORETURN __attribute__((noreturn))&#10;#elif defined(_MSC_VER)&#10;    #define DS_NODISCARD _Check_return_&#10;    #define DS_DEPRECATED __declspec(deprecated)&#10;    #define DS_NORETURN __declspec(noreturn)&#10;#else&#10;    #define DS_NODISCARD&#10;    #define DS_DEPRECATED&#10;    #define DS_NORETURN&#10;#endif&#10;&#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif /* DS_CSTANDARDCOMPATIBILITY_H */&#10;" />
              <option name="updatedContent" value="//&#10;// Created by zack on 8/27/25.&#10;//&#10;&#10;#ifndef DS_CSTANDARDCOMPATIBILITY_H&#10;#define DS_CSTANDARDCOMPATIBILITY_H&#10;&#10;#include &quot;PlatformDefs.h&quot;&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/* Require C11 or higher */&#10;#if !defined(__STDC_VERSION__) || __STDC_VERSION__ &lt; 201112L&#10;    #error &quot;C11 or higher required&quot;&#10;#endif&#10;&#10;/* Detect C23 for standard attributes */&#10;#if __STDC_VERSION__ &gt;= 202311L&#10;    #define COMPAT_HAS_C23 1&#10;#endif&#10;&#10;#if !defined(COMPAT_HAS_C23) || !defined(__cplusplus)&#10;    #define nullptr ((void*)0)&#10;    #define constexpr const&#10;    #include &lt;stdbool.h&gt;&#10;    #define static_assert(condition, message) _Static_assert(condition, message)&#10;#endif&#10;    &#10;/* Attribute compatibility macros */&#10;#ifdef COMPAT_HAS_C23&#10;    #define DS_NODISCARD [[nodiscard]]&#10;    #define DS_DEPRECATED [[deprecated]]&#10;    #define DS_NORETURN [[noreturn]]&#10;#elif defined(__GNUC__) || defined(__clang__)&#10;    #define DS_NODISCARD __attribute__((warn_unused_result))&#10;    #define DS_DEPRECATED __attribute__((deprecated))&#10;    #define DS_NORETURN __attribute__((noreturn))&#10;#elif defined(_MSC_VER)&#10;    #define DS_NODISCARD _Check_return_&#10;    #define DS_DEPRECATED __declspec(deprecated)&#10;    #define DS_NORETURN __declspec(noreturn)&#10;#else&#10;    #define DS_NODISCARD&#10;    #define DS_DEPRECATED&#10;    #define DS_NORETURN&#10;#endif&#10;&#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif /* DS_CSTANDARDCOMPATIBILITY_H */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/Iterator.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/Iterator.h" />
              <option name="originalContent" value="//&#10;// Created by zack on 8/26/25.&#10;//&#10;// Iterator interface for generic data traversal.&#10;// This implementation provides a flexible iterator pattern that can be&#10;// used with any data structure, with support for transformation and filtering.&#10;&#10;#ifndef DS_ITERATOR_H&#10;#define DS_ITERATOR_H&#10;&#10;//==============================================================================&#10;// Iterator interface&#10;//==============================================================================&#10;&#10;/**&#10; * Generic iterator structure.&#10; * Provides a common interface for traversing different data structures.&#10; */&#10;typedef struct Iterator Iterator;&#10;&#10;/**&#10; * Iterator interface with function pointers for standard operations.&#10; */&#10;struct Iterator&#10;{&#10;    void *data_state;              // Implementation-specific state data&#10;&#10;    // Element access&#10;    void *(*get)(const Iterator *it);  // Get current element without advancing&#10;&#10;    // Forward iteration&#10;    int (*has_next)(const Iterator *it);  // Check if more elements exist&#10;    void *(*next)(const Iterator *it);    // Get next element and advance&#10;&#10;    // Backward iteration&#10;    int (*has_prev)(const Iterator *it);  // Check if previous elements exist&#10;    void *(*prev)(const Iterator *it);    // Get previous element and move back&#10;&#10;    // Control operations&#10;    void (*reset)(const Iterator *it);    // Reset to starting position&#10;    int (*is_valid)(const Iterator *it);  // Check if iterator is valid&#10;&#10;    // Resource management&#10;    void (*destroy)(Iterator *it);        // Free iterator resources&#10;};&#10;&#10;//==============================================================================&#10;// Function pointer types&#10;//==============================================================================&#10;&#10;/**&#10; * Transformation function: creates a new element from an existing one.&#10; *&#10; * @param element The source element to transform&#10; * @return A new element derived from the source&#10; */&#10;typedef void *(*transform_func)(const void *element);&#10;&#10;/**&#10; * Filter predicate function: tests if elements should be included.&#10; *&#10; * @param element The element to test&#10; * @return Non-zero to include element, 0 to exclude&#10; */&#10;typedef int (*filter_func)(const void *element);&#10;&#10;//==============================================================================&#10;// Higher-order iterator functions&#10;//==============================================================================&#10;&#10;/**&#10; * Create a transforming iterator that applies a function to each element.&#10; * The new iterator produces transformed elements on-the-fly.&#10; *&#10; * Note: The returned iterator takes ownership of the source iterator&#10; * and will destroy it when the transform iterator is destroyed.&#10; *&#10; * @param it Base iterator to transform (ownership transferred)&#10; * @param transform Function to apply to each element&#10; * @return A new iterator producing transformed elements&#10; */&#10;Iterator iterator_transform(Iterator *it, transform_func transform);&#10;&#10;/**&#10; * Create a filtering iterator that only yields elements matching a predicate.&#10; * The new iterator skips elements that don't satisfy the filter function.&#10; *&#10; * Note: The returned iterator takes ownership of the source iterator&#10; * and will destroy it when the filter iterator is destroyed.&#10; *&#10; * @param it Base iterator to filter (ownership transferred)&#10; * @param filter Predicate function that determines which elements to include&#10; * @return A new iterator yielding only elements that satisfy the predicate&#10; */&#10;Iterator iterator_filter(Iterator *it, filter_func filter);&#10;&#10;/**&#10; * Create an iterator that yields integers in a specified range.&#10; * &#10; * @param start Starting value (inclusive)&#10; * @param end Ending value (exclusive)&#10; * @param step Step value (positive or negative, non-zero)&#10; * @return A new iterator yielding integers in the specified range&#10; */&#10;Iterator iterator_range(int start, int end, int step);&#10;&#10;#endif //DS_ITERATOR_H" />
              <option name="updatedContent" value="//&#10;// Created by zack on 8/26/25.&#10;//&#10;// Iterator interface for generic data traversal.&#10;// This implementation provides a flexible iterator pattern that can be&#10;// used with any data structure, with support for transformation and filtering.&#10;&#10;#ifndef DS_ITERATOR_H&#10;#define DS_ITERATOR_H&#10;&#10;//==============================================================================&#10;// Iterator interface&#10;//==============================================================================&#10;&#10;/**&#10; * Generic iterator structure.&#10; * Provides a common interface for traversing different data structures.&#10; */&#10;typedef struct Iterator Iterator;&#10;&#10;/**&#10; * Iterator interface with function pointers for standard operations.&#10; */&#10;struct Iterator&#10;{&#10;    void *data_state;              // Implementation-specific state data&#10;&#10;    // Element access&#10;    void *(*get)(const Iterator *it);  // Get current element without advancing&#10;&#10;    // Forward iteration&#10;    int (*has_next)(const Iterator *it);  // Check if more elements exist&#10;    void *(*next)(const Iterator *it);    // Get next element and advance&#10;&#10;    // Backward iteration&#10;    int (*has_prev)(const Iterator *it);  // Check if previous elements exist&#10;    void *(*prev)(const Iterator *it);    // Get previous element and move back&#10;&#10;    // Control operations&#10;    void (*reset)(const Iterator *it);    // Reset to starting position&#10;    int (*is_valid)(const Iterator *it);  // Check if iterator is valid&#10;&#10;    // Resource management&#10;    void (*destroy)(Iterator *it);        // Free iterator resources&#10;};&#10;&#10;//==============================================================================&#10;// Function pointer types&#10;//==============================================================================&#10;&#10;/**&#10; * Transformation function: creates a new element from an existing one.&#10; *&#10; * @param element The source element to transform&#10; * @return A new element derived from the source&#10; */&#10;typedef void *(*transform_func)(const void *element);&#10;&#10;/**&#10; * Filter predicate function: tests if elements should be included.&#10; *&#10; * @param element The element to test&#10; * @return Non-zero to include element, 0 to exclude&#10; */&#10;typedef int (*filter_func)(const void *element);&#10;&#10;//==============================================================================&#10;// Higher-order iterator functions&#10;//==============================================================================&#10;&#10;/**&#10; * Create a transforming iterator that applies a function to each element.&#10; * The new iterator produces transformed elements on-the-fly.&#10; *&#10; * Note: The returned iterator takes ownership of the source iterator&#10; * and will destroy it when the transform iterator is destroyed.&#10; *&#10; * @param it Base iterator to transform (ownership transferred)&#10; * @param transform Function to apply to each element&#10; * @return A new iterator producing transformed elements&#10; */&#10;Iterator iterator_transform(Iterator *it, transform_func transform);&#10;&#10;/**&#10; * Create a filtering iterator that only yields elements matching a predicate.&#10; * The new iterator skips elements that don't satisfy the filter function.&#10; *&#10; * Note: The returned iterator takes ownership of the source iterator&#10; * and will destroy it when the filter iterator is destroyed.&#10; *&#10; * @param it Base iterator to filter (ownership transferred)&#10; * @param filter Predicate function that determines which elements to include&#10; * @return A new iterator yielding only elements that satisfy the predicate&#10; */&#10;Iterator iterator_filter(Iterator *it, filter_func filter);&#10;&#10;/**&#10; * Create an iterator that yields integers in a specified range.&#10; * &#10; * @param start Starting value (inclusive)&#10; * @param end Ending value (exclusive)&#10; * @param step Step value (positive or negative, non-zero)&#10; * @return A new iterator yielding integers in the specified range&#10; */&#10;Iterator iterator_range(int start, int end, int step);&#10;&#10;#endif //DS_ITERATOR_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/PlatformDefs.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/PlatformDefs.h" />
              <option name="originalContent" value="#ifndef DS_PLATFORM_DEFS_H&#10;#define DS_PLATFORM_DEFS_H&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/* Platform detection - use CMake definitions if available, otherwise auto-detect */&#10;#if !defined(DS_PLATFORM_WINDOWS) &amp;&amp; !defined(DS_PLATFORM_MACOS) &amp;&amp; !defined(DS_PLATFORM_LINUX)&#10;    #if defined(_WIN32) || defined(_WIN64)&#10;        #define DS_PLATFORM_WINDOWS 1&#10;    #elif defined(__APPLE__) || defined(__MACH__)&#10;        #define DS_PLATFORM_MACOS 1&#10;    #elif defined(__linux__)&#10;        #define DS_PLATFORM_LINUX 1&#10;    #else&#10;        #define DS_PLATFORM_UNKNOWN 1&#10;    #endif&#10;#endif&#10;    &#10;/* API export/import macros */&#10;#ifdef DS_PLATFORM_WINDOWS&#10;    #ifdef DS_BUILDING_DLL&#10;        #define DS_API __declspec(dllexport)&#10;    #else&#10;        #define DS_API __declspec(dllimport)&#10;    #endif&#10;#elif defined(__GNUC__) || defined(__clang__)&#10;    #define DS_API __attribute__((visibility(&quot;default&quot;)))&#10;#else&#10;    #define DS_API&#10;#endif&#10;    &#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif /* DS_PLATFORM_DEFS_H */&#10;" />
              <option name="updatedContent" value="#ifndef DS_PLATFORM_DEFS_H&#10;#define DS_PLATFORM_DEFS_H&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/* Platform detection - use CMake definitions if available, otherwise auto-detect */&#10;#if !defined(DS_PLATFORM_WINDOWS) &amp;&amp; !defined(DS_PLATFORM_MACOS) &amp;&amp; !defined(DS_PLATFORM_LINUX)&#10;    #if defined(_WIN32) || defined(_WIN64)&#10;        #define DS_PLATFORM_WINDOWS 1&#10;    #elif defined(__APPLE__) || defined(__MACH__)&#10;        #define DS_PLATFORM_MACOS 1&#10;    #elif defined(__linux__)&#10;        #define DS_PLATFORM_LINUX 1&#10;    #else&#10;        #define DS_PLATFORM_UNKNOWN 1&#10;    #endif&#10;#endif&#10;    &#10;/* API export/import macros */&#10;#ifdef DS_PLATFORM_WINDOWS&#10;    #ifdef DS_BUILDING_DLL&#10;        #define DS_API __declspec(dllexport)&#10;    #else&#10;        #define DS_API __declspec(dllimport)&#10;    #endif&#10;#elif defined(__GNUC__) || defined(__clang__)&#10;    #define DS_API __attribute__((visibility(&quot;default&quot;)))&#10;#else&#10;    #define DS_API&#10;#endif&#10;    &#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif /* DS_PLATFORM_DEFS_H */" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>